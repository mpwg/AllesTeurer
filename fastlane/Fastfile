# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Load environment variables from .env file if it exists, otherwise use system environment variables
env_file_path = File.join(File.dirname(__FILE__), '..', '.env')
if File.exist?(env_file_path)
  require 'dotenv'
  Dotenv.load(env_file_path)
  UI.message("ğŸ“„ Loaded environment variables from .env file")
else
  UI.message("ğŸŒ Using system environment variables (no .env file found)")
end

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

# Global configuration
APP_IDENTIFIER = "eu.mpwg.Alles-Teurer"
SCHEME_NAME = "Alles-Teurer"
WORKSPACE_PATH = "./Alles-Teurer.xcodeproj"

platform :ios do
  before_all do

    # Setup keychain for CI
    if is_ci
      create_keychain(
        name: "CI",
        password: ENV["KEYCHAIN_PASSWORD"],
        default_keychain: true,
        unlock: true,
        timeout: 3600,
        lock_when_sleeps: false
      )
    end
  end

  # MARK: - Tag-based Version Management Helper Functions
  
  private_lane :get_tag_version do
    # Get version from git tag if available, otherwise return nil
    if is_ci && ENV['GITHUB_REF'] && ENV['GITHUB_REF'].include?('refs/tags/')
      # Extract tag name from GitHub ref (refs/tags/v1.0.0 -> v1.0.0)
      tag = ENV['GITHUB_REF'].split('refs/tags/').last
      # Remove 'v' prefix if present (v1.0.0 -> 1.0.0)
      tag.start_with?('v') ? tag[1..-1] : tag
    else
      # Try to get tag from current commit
      begin
        sh("git describe --tags --exact-match HEAD 2>/dev/null || echo ''", log: false).strip
      rescue
        nil
      end
    end
  end
  
  private_lane :set_version_from_tag do
    tag_version = get_tag_version
    if tag_version && !tag_version.empty?
      # Remove 'v' prefix and any pre-release suffixes for the main version number
      clean_version = tag_version.gsub(/^v/, '').split('-').first
      
      UI.message("ğŸ“‹ Setting version from tag: #{tag_version} -> #{clean_version}")
      
      increment_version_number(
        version_number: clean_version,
        xcodeproj: WORKSPACE_PATH
      )
      
      # For build number, use timestamp or incremental approach
      if tag_version.include?('-')
        # Pre-release: use timestamp for uniqueness
        build_number = Time.now.strftime("%Y%m%d%H%M")
      else
        # Production release: use incremental build number
        begin
          latest_build = latest_testflight_build_number || 0
          build_number = latest_build + 1
        rescue
          build_number = 1
        end
      end
      
      increment_build_number(
        build_number: build_number,
        xcodeproj: WORKSPACE_PATH
      )
      
      UI.success("âœ… Version set to #{clean_version} (#{build_number}) from tag #{tag_version}")
    else
      UI.message("ğŸ“‹ No tag found, keeping current version")
    end
  end

  after_all do |lane|
    # Clean up keychain on CI
    if is_ci
      delete_keychain(name: "CI")
    end
  end

  error do |lane, exception|
    # Clean up keychain on CI even if there's an error
    if is_ci
      delete_keychain(name: "CI") rescue nil
    end
  end

  # MARK: - Multi-Platform Build Functions
  
  private_lane :build_multiplatform do |options|
    # Build for iOS/iPadOS
    ios_ipa = build_ios_platform(options)
    
    # Build for macOS (Mac Catalyst) 
    macos_app = build_macos_platform(options)
    
    {
      ios_ipa: ios_ipa,
      macos_app: macos_app
    }
  end
  
  private_lane :build_ios_platform do |options|
    UI.header("ğŸ“± Building iOS/iPadOS version")
    
    # Build configuration with proper export options override
    build_config = common_build_config.merge({
      configuration: options[:configuration] || "Release",
      export_method: options[:export_method],
      output_directory: options[:output_directory],
      output_name: "#{SCHEME_NAME}-iOS-#{options[:version] || 'latest'}.ipa",
      skip_profile_detection: options[:skip_profile_detection] || true,
      destination: "generic/platform=iOS"
    })
    
    # Override export method in export_options
    build_config[:export_options][:method] = options[:export_method]
    
    build_app(build_config)
    
    File.join(options[:output_directory], "#{SCHEME_NAME}-iOS-#{options[:version] || 'latest'}.ipa")
  end
  
  private_lane :build_macos_platform do |options|
    UI.header("ğŸ–¥ï¸ Building macOS (Mac Catalyst) version")
    
    # Sync Mac Catalyst certificates specifically for macOS builds
    begin
      match(
        type: "development",
        platform: "catalyst",
        app_identifier: APP_IDENTIFIER,
        git_url: ENV["MATCH_GIT_URL"],
        git_basic_authorization: ENV["MATCH_GIT_BASIC_AUTHORIZATION"],
        keychain_name: is_ci ? "CI" : nil,
        keychain_password: is_ci ? ENV["KEYCHAIN_PASSWORD"] : nil,
        readonly: is_ci,
        verbose: true,
        skip_confirmation: true,
        shallow_clone: true
      )
    rescue => e
      UI.error("âš ï¸ Failed to sync Mac Catalyst certificates: #{e.message}")
      UI.error("ğŸ“± Skipping macOS build")
      return nil
    end
    
    # For Mac Catalyst, we use the same export method as iOS since it's an iOS app on macOS
    export_method = options[:export_method] || "development"
    
    # Build configuration with proper export options override
    build_config = common_build_config.merge({
      configuration: options[:configuration] || "Release",
      export_method: export_method,
      output_directory: options[:output_directory],
      output_name: "#{SCHEME_NAME}-macOS-#{options[:version] || 'latest'}",
      skip_profile_detection: options[:skip_profile_detection] || false,
      destination: "platform=macOS,variant=Mac Catalyst",
      catalyst_platform: "macos"
    })
    
    # Override export method in export_options for Mac Catalyst
    build_config[:export_options][:method] = export_method
    build_config[:export_options][:provisioningProfiles] = {
      APP_IDENTIFIER => ENV["sigh_#{APP_IDENTIFIER}_development_catalyst_profile-name"] || "match Development #{APP_IDENTIFIER} catalyst"
    }
    
    build_app(build_config)
    
    File.join(options[:output_directory], "#{SCHEME_NAME}-macOS-#{options[:version] || 'latest'}.app")
  end

  # MARK: - Development Builds

  desc "Build development version for testing"
  lane :dev do
    setup_ci_if_needed

    sync_certificates(type: "development")

    build_app(common_build_config.merge({
      configuration: "Debug",
      export_method: "development",
      output_directory: "./build/development",
      output_name: "#{SCHEME_NAME}-development.ipa",
      skip_profile_detection: false
    }))

    UI.success("âœ… Development build completed successfully!")
  end

  # MARK: - Beta Builds (TestFlight)

  desc "Build and upload to TestFlight"
  lane :beta do
    setup_ci_if_needed

    # Set version from tag if available
    set_version_from_tag
    tag_version = get_tag_version || "beta"

    sync_certificates(type: "appstore")

    # Build both platforms
    UI.header("ğŸš€ Building multi-platform beta release")
    
    builds = build_multiplatform({
      configuration: "Release",
      export_method: "app-store",
      output_directory: "./build/testflight",
      version: tag_version,
      skip_profile_detection: true
    })

    # Upload iOS version to TestFlight
    UI.header("ğŸ“± Uploading iOS version to TestFlight")
    
    # Create changelog from tag or use default
    changelog = if tag_version && tag_version.include?('-')
      "Beta release #{tag_version}"
    else
      "Bug fixes and improvements"
    end

    upload_to_testflight(
      app_identifier: APP_IDENTIFIER,
      ipa: builds[:ios_ipa],
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      notify_external_testers: false,
      changelog: changelog
    )

    UI.success("âœ… TestFlight upload completed successfully!")
    UI.success("ğŸ“± iOS version: #{builds[:ios_ipa]}")
    UI.success("ğŸ–¥ï¸  macOS version: #{builds[:macos_app]}")
    if tag_version
      UI.success("ğŸ·ï¸  Released from tag: #{tag_version}")
    end
    
    # Return build paths for GitHub Release creation
    builds
  end

  # MARK: - Alpha Builds (GitHub Releases only)

  desc "Build alpha versions for GitHub Releases (no store upload)"
  lane :alpha do
    setup_ci_if_needed

    # Set version from tag if available
    set_version_from_tag
    tag_version = get_tag_version || "alpha"

    sync_certificates(type: "development")

    # Build both platforms for direct distribution
    UI.header("ğŸš€ Building multi-platform alpha release")
    
    builds = build_multiplatform({
      configuration: "Release",
      export_method: "development", # For direct distribution 
      output_directory: "./build/alpha",
      version: tag_version,
      skip_profile_detection: false  # Enable profile detection to ensure proper signing
    })

    UI.success("âœ… Alpha builds completed successfully!")
    UI.success("ğŸ“± iOS version: #{builds[:ios_ipa]}")
    UI.success("ğŸ–¥ï¸  macOS version: #{builds[:macos_app]}")
    if tag_version
      UI.success("ğŸ·ï¸  Built from tag: #{tag_version}")
    end
    
    # Return build paths for GitHub Release creation
    builds
  end

  # MARK: - Production Builds (App Store)

  desc "Build and upload to App Store"
  lane :release do
    setup_ci_if_needed

    # Set version from tag if available
    set_version_from_tag
    tag_version = get_tag_version || "release"

    sync_certificates(type: "appstore")

    # Build both platforms
    UI.header("ğŸš€ Building multi-platform production release")
    
    builds = build_multiplatform({
      configuration: "Release",
      export_method: "app-store",
      output_directory: "./build/appstore",
      version: tag_version,
      skip_profile_detection: true
    })

    # Upload iOS version to App Store
    UI.header("ğŸ“± Uploading iOS version to App Store")
    
    upload_to_app_store(
      app_identifier: APP_IDENTIFIER,
      ipa: builds[:ios_ipa],
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false, # Manual submission for production
      automatic_release: false,
      force: true
    )

    current_version = get_version_number(xcodeproj: WORKSPACE_PATH)

    UI.success("âœ… App Store upload completed successfully!")
    UI.success("ğŸ“± iOS version: #{builds[:ios_ipa]}")
    UI.success("ğŸ–¥ï¸  macOS version: #{builds[:macos_app]}")
    if tag_version
      UI.success("ğŸ·ï¸  Released from tag: #{tag_version}")
    end
    UI.success("ğŸ“± Version uploaded: #{current_version}")
    
    # Return build paths for GitHub Release creation
    builds
  end

  # MARK: - Testing

  desc "Run unit tests and build for CI validation"
  lane :test do
    UI.message("ğŸ§ª Running unit tests with Mac Catalyst for maximum speed")
    
    # Clean build directory first
    sh("rm -rf ../build/test-results || true")
    sh("mkdir -p ../build/test-results")
    
    # Build and test with Mac Catalyst using xcodebuild directly
    # This is 5x faster than iOS simulator as it runs natively on macOS
    # Only run unit tests, not UI tests, as UI tests don't work well with Mac Catalyst
    sh("set -o pipefail && xcodebuild test -project ../#{WORKSPACE_PATH} -scheme #{SCHEME_NAME} -destination 'platform=macOS,variant=Mac Catalyst' -only-testing:Alles-TeurerTests -resultBundlePath ../build/test-results/Alles-Teurer-Catalyst.xcresult CODE_SIGNING_ALLOWED=NO -allowProvisioningUpdates #{build_xcargs} | xcpretty || true")

    UI.success("âœ… Mac Catalyst unit tests completed!")
  end

  desc "Run tests on iOS Simulator (manual use for iOS-specific testing)"
  lane :test_ios do
    UI.message("ğŸ§ª Running tests on iOS Simulator for iOS-specific testing")
    
    # iOS Simulator testing for iOS-specific functionality
    run_tests(
      project: WORKSPACE_PATH,
      scheme: SCHEME_NAME,
      devices: ["iPhone 17"],  # Keep iPhone 17 as requested
      clean: false,  # Keep incremental builds for speed
      code_coverage: false,  # Disable coverage for faster execution
      skip_build: false,
      result_bundle: true,
      output_directory: "./build/test-results-ios",
      buildlog_path: "./build/logs",
      xcargs: "CODE_SIGNING_ALLOWED=NO -allowProvisioningUpdates #{build_xcargs}"
    )

    UI.success("âœ… iOS Simulator tests completed successfully!")
  end

  # MARK: - Build Only (for CI validation)

  desc "Build app without distribution (for CI validation)"
  lane :build do
    setup_ci_if_needed

    # Use Mac Catalyst for faster builds (no code signing needed for validation)
    UI.message("ğŸ—ï¸ Building with Mac Catalyst for fast CI validation")
    
    sh("set -o pipefail && xcodebuild build -project ../#{WORKSPACE_PATH} -scheme #{SCHEME_NAME} -destination 'platform=macOS,variant=Mac Catalyst' CODE_SIGNING_ALLOWED=NO -allowProvisioningUpdates #{build_xcargs} | xcpretty")

    UI.success("âœ… Mac Catalyst build validation completed successfully!")
  end

  desc "Build app for iOS distribution"
  lane :build_ios do
    setup_ci_if_needed

    sync_certificates(type: "development")

    build_app(common_build_config.merge({
      configuration: "Debug",
      export_method: "development",
      output_directory: "./build/validation",
      output_name: "#{SCHEME_NAME}-validation.ipa",
      skip_profile_detection: true,
      skip_archive: false
    }))

    UI.success("âœ… iOS build validation completed successfully!")
  end

  desc "Clean build when incremental builds are causing issues"
  lane :clean_build do
    setup_ci_if_needed

    sync_certificates(type: "development")

    build_app(common_build_config.merge({
      configuration: "Debug",
      export_method: "development",
      output_directory: "./build/validation",
      output_name: "#{SCHEME_NAME}-clean-build.ipa",
      skip_profile_detection: true,
      skip_archive: false,
      clean: true  # Force clean build
    }))

    UI.success("âœ… Clean build completed successfully!")
  end

  # MARK: - Code Signing

  desc "Sync development certificates and provisioning profiles"
  lane :certificates do
    setup_ci_if_needed
    sync_certificates(type: "development")
    sync_certificates(type: "appstore")
  end

  desc "Update certificates and push to git"
  lane :update_certificates do
    configure_app_store_connect
    UI.success("DEBUG: Before updating certificates")

    match(
      type: "development",
      app_identifier: APP_IDENTIFIER,
      git_url: ENV["MATCH_GIT_URL"],
      git_basic_authorization: ENV["MATCH_GIT_BASIC_AUTHORIZATION"],
      force_for_new_devices: true,
      readonly: false,
      verbose: true
    )
    UI.success("DEBUG: After updating development certificates")
    match(
      type: "appstore",
      app_identifier: APP_IDENTIFIER,
      git_url: ENV["MATCH_GIT_URL"],
      git_basic_authorization: ENV["MATCH_GIT_BASIC_AUTHORIZATION"],
      readonly: false,
      verbose: true
    )
    UI.success("âœ… Certificates updated and pushed to git!")
  end

  # MARK: - Helper Methods

  private_lane :setup_ci_if_needed do
    if is_ci
      setup_ci
    end
  end

  private_lane :common_build_config do
    {
      scheme: SCHEME_NAME,
      project: WORKSPACE_PATH,
      clean: false,  # Improved: Only clean when necessary for faster incremental builds
      include_bitcode: false,
      # Force manual code signing with Match profiles
      export_xcargs: "-allowProvisioningUpdates",
      # Performance optimizations
      xcargs: build_xcargs,
      # Manual code signing configuration
      codesigning_identity: "Apple Development",
      export_options: {
        method: "development", # This will be overridden by each lane
        provisioningProfiles: {
          APP_IDENTIFIER => ENV["sigh_#{APP_IDENTIFIER}_development_profile-name"] || "match Development #{APP_IDENTIFIER}"
        }
      }
    }
  end

  private_lane :build_xcargs do
    args = []
    
    # Enable parallel builds for faster compilation
    args << "-jobs #{ENV.fetch('FASTLANE_BUILD_JOBS', `sysctl -n hw.logicalcpu`.strip)}"
    
    # Use optimized linker for faster linking
    args << "OTHER_LDFLAGS=\"-Wl,-no_deduplicate\""
    
    # Enable build caching
    args << "CLANG_ENABLE_MODULE_DEBUGGING=NO"  # Faster for CI builds
    
    # Force manual code signing (disable automatic signing)
    args << "CODE_SIGN_STYLE=Manual" if is_ci
    
    # Allow provisioning profile updates but use manual signing
    args << "-allowProvisioningUpdates" if is_ci
    
    # Swift compilation optimizations
    args << "SWIFT_COMPILATION_MODE=incremental" if !is_ci
    
    args.join(" ")
  end

  private_lane :configure_app_store_connect do
    if ENV["FASTLANE_SESSION"]
      UI.message("ğŸ”‘ Using FASTLANE_SESSION for App Store Connect authentication")
    else
      UI.message("âš ï¸  FASTLANE_SESSION not configured - some operations may require manual authentication")
    end
  end

  private_lane :sync_certificates do |options|
    type = options[:type]

    # Validate required environment variables
    required_match_vars = ["MATCH_GIT_URL", "MATCH_PASSWORD"]
    missing_vars = required_match_vars.select { |var| ENV[var].nil? || ENV[var].empty? }

    if missing_vars.any?
      UI.error("âŒ Missing required environment variables for fastlane match: #{missing_vars.join(', ')}")
      UI.error("ğŸ’¡ Please check your .env file or environment configuration")
      raise "Missing required environment variables for code signing"
    end

    # Configure App Store Connect authentication if available (required for creating new certificates)
    configure_app_store_connect

    UI.message("ğŸ” Syncing #{type} certificates and provisioning profiles with fastlane match")
    UI.message("ğŸš§ Ensuring Fastlane handles code signing (not Xcode automatic signing)")

    begin
      match(
        type: type,
        app_identifier: APP_IDENTIFIER,
        git_url: ENV["MATCH_GIT_URL"],
        git_basic_authorization: ENV["MATCH_GIT_BASIC_AUTHORIZATION"],
        keychain_name: is_ci ? "CI" : nil,
        keychain_password: is_ci ? ENV["KEYCHAIN_PASSWORD"] : nil,
        readonly: is_ci,
        verbose: true,
        # Ensure Fastlane manages signing, not Xcode
        skip_confirmation: true,
        shallow_clone: true
      )
      UI.success("âœ… Successfully synced #{type} certificates")
      UI.message("ğŸ”’ Code signing will be handled by Fastlane, not Xcode")
    rescue => e
      UI.error("âŒ Failed to sync certificates: #{e.message}")
      UI.error("ğŸ’¡ Common solutions:")
      UI.error("   â€¢ Check MATCH_PASSWORD is correct")
      UI.error("   â€¢ Verify MATCH_GIT_URL is accessible")
      UI.error("   â€¢ Ensure certificates exist in match repository")
      UI.error("   â€¢ Run 'fastlane update_certificates' if certificates need to be created")
      raise e
    end
  end

  # MARK: - Utility Lanes

  desc "Show current version and build number"
  lane :version do
    version = get_version_number(xcodeproj: WORKSPACE_PATH)
    build = get_build_number(xcodeproj: WORKSPACE_PATH)
    UI.message("ğŸ“± Current version: #{version} (#{build})")
  end

  desc "Show available lanes"
  lane :show_help do
    UI.header("ğŸ“‹ Available Fastlane Lanes")
    UI.message("ğŸ§ª Testing:")
    UI.message("  â€¢ fastlane test       - Run unit tests and build for CI validation")
    UI.message("")
    UI.message("ğŸ”¨ Development:")
    UI.message("  â€¢ fastlane dev        - Build development version")
    UI.message("  â€¢ fastlane build      - Build for CI validation")
    UI.message("  â€¢ fastlane clean_build - Clean build when incremental builds fail")
    UI.message("")
    UI.message("ğŸ§ª Testing:")
    UI.message("  â€¢ fastlane beta       - Build and upload to TestFlight")
    UI.message("")
    UI.message("ğŸš€ Production:")
    UI.message("  â€¢ fastlane release    - Build and upload to App Store")
    UI.message("")
    UI.message("ğŸ” Code Signing:")
    UI.message("  â€¢ fastlane certificates        - Sync existing certificates")
    UI.message("  â€¢ fastlane update_certificates - Update and push new certificates")
    UI.message("")
    UI.message("â„¹ï¸  Utility:")
    UI.message("  â€¢ fastlane version   - Show current app version")
    UI.message("  â€¢ fastlane benchmark - Run build performance benchmark")
    UI.message("  â€¢ fastlane show_help - Show this help")
  end

  desc "Run build performance benchmark"
  lane :benchmark do
    UI.header("ğŸš€ Build Performance Benchmark")
    
    start_time = Time.now
    
    # Clean build for baseline
    UI.message("Running clean build benchmark...")
    clean_start = Time.now
    
    build_app(common_build_config.merge({
      configuration: "Debug",
      export_method: "development",
      output_directory: "./build/benchmark",
      output_name: "#{SCHEME_NAME}-benchmark-clean.ipa",
      skip_profile_detection: true,
      skip_archive: true,
      clean: true
    }))
    
    clean_duration = Time.now - clean_start
    
    # Incremental build
    UI.message("Running incremental build benchmark...")
    incremental_start = Time.now
    
    build_app(common_build_config.merge({
      configuration: "Debug",
      export_method: "development",
      output_directory: "./build/benchmark",
      output_name: "#{SCHEME_NAME}-benchmark-incremental.ipa",
      skip_profile_detection: true,
      skip_archive: true,
      clean: false
    }))
    
    incremental_duration = Time.now - incremental_start
    total_duration = Time.now - start_time
    
    UI.success("ğŸ“Š Build Performance Results:")
    UI.success("  â€¢ Clean build time: #{clean_duration.round(2)} seconds")
    UI.success("  â€¢ Incremental build time: #{incremental_duration.round(2)} seconds")
    UI.success("  â€¢ Time saved with incremental builds: #{(clean_duration - incremental_duration).round(2)} seconds")
    UI.success("  â€¢ Total benchmark time: #{total_duration.round(2)} seconds")
    UI.success("  â€¢ Performance improvement: #{((clean_duration - incremental_duration) / clean_duration * 100).round(1)}%")
  end
end
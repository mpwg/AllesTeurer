# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# AllesTeurer Tag-Based Release System:
# - CI builds: Run on every push/PR (build + test only)
# - Alpha releases: v*.*.*-alpha.* ‚Üí GitHub Release with .ipa and .app
# - Beta releases: v*.*.*-beta.* ‚Üí TestFlight + GitHub Release
# - Production releases: v*.*.* ‚Üí App Store + GitHub Release
#
# All releases support iOS/iPadOS and macOS (Mac Catalyst) platforms

require 'dotenv'

# Load environment variables
env_file_path = File.join(File.dirname(__FILE__), '..', '.env')
if File.exist?(env_file_path)
  Dotenv.load(env_file_path)
  UI.message("üìÑ Loaded environment variables from .env file")
else
  UI.message("üåç Using system environment variables (no .env file found)")
end

default_platform(:ios)

# Global configuration
APP_IDENTIFIER = "eu.mpwg.Alles-Teurer"
SCHEME_NAME = "Alles-Teurer"
WORKSPACE_PATH = "./Alles-Teurer.xcodeproj"

# Match configuration
MATCH_TYPE_DEVELOPMENT = "development"
MATCH_TYPE_ADHOC = "adhoc"
MATCH_TYPE_APPSTORE = "appstore"

# Custom keychain configuration
FASTLANE_KEYCHAIN_NAME = ENV["MATCH_KEYCHAIN_NAME"] || "fastlane-alles-teurer"
FASTLANE_KEYCHAIN_PASSWORD = ENV["MATCH_PASSWORD"] || ENV["KEYCHAIN_PASSWORD"]

platform :ios do
  before_all do |lane|
    UI.header("üöÄ Starting lane: #{lane}")
    UI.message("üì± App: #{APP_IDENTIFIER}")
    UI.message("üîß Scheme: #{SCHEME_NAME}")
    UI.message("üåç CI: #{is_ci}")
    
    # Setup CI environment if needed
    setup_ci if is_ci
    
    # Configure App Store Connect if needed
    configure_app_store_connect_if_needed
  end

  after_all do |lane|
    UI.success("‚úÖ Lane completed: #{lane}")
  end

  error do |lane, exception|
    UI.error("‚ùå Lane failed: #{lane}")
    UI.error("Error: #{exception.message}")
    raise exception
  end

  # MARK: - CI Lanes (Build and Test)

  desc "CI build and test (no deployment)"
  lane :ci do
    UI.header("üî® CI Build and Test")
    # Ensure Mac Catalyst development certs are available in CI
    sync_code_signing(
      type: MATCH_TYPE_DEVELOPMENT,
      additional_platforms: ["catalyst"]
    )
    # Run tests first
    test_all_platforms
    # Build for validation (both iOS and Mac Catalyst)
    validate_builds
    UI.success("‚úÖ CI validation completed successfully!")
  end

  desc "Run all tests"
  lane :test do
    # Ensure Mac Catalyst development certs are available in CI
    sync_code_signing(
      type: MATCH_TYPE_DEVELOPMENT,
      additional_platforms: ["catalyst"]
    )
    test_all_platforms
  end

  # MARK: - Release Lanes (Tag-Based)

  desc "Alpha release to GitHub (v*.*.*-alpha.*)"
  lane :alpha do
    UI.header("üî¨ Alpha Release")
    
    version_info = parse_and_set_version
    UI.message("üì¶ Building alpha #{version_info[:version]} (#{version_info[:build]})")
    
    # Sync certificates and profiles for development distribution
    sync_code_signing(
      type: MATCH_TYPE_DEVELOPMENT,
      additional_platforms: ["catalyst"]
    )
    
    # Build both platforms
    builds = build_multiplatform(
      configuration: "Release",
      export_method: "development",
      output_directory: "./build/alpha",
      version: version_info[:version],
      match_type: MATCH_TYPE_DEVELOPMENT
    )
    
    UI.success("‚úÖ Alpha builds completed:")
    UI.success("  üì± iOS: #{builds[:ios_ipa]}")
    UI.success("  üñ•Ô∏è macOS: #{builds[:macos_app]}")
    
    builds
  end

  desc "Beta release to TestFlight (v*.*.*-beta.*)"
  lane :beta do
    UI.header("üß™ Beta Release to TestFlight")
    
    version_info = parse_and_set_version
    UI.message("üì¶ Building beta #{version_info[:version]} (#{version_info[:build]})")
    
    # Sync certificates and profiles for App Store distribution
    sync_code_signing(
      type: MATCH_TYPE_APPSTORE,
      additional_platforms: ["catalyst"]
    )
    
    # Build both platforms
    builds = build_multiplatform(
      configuration: "Release",
      export_method: "app-store",
      output_directory: "./build/beta",
      version: version_info[:version],
      match_type: MATCH_TYPE_APPSTORE
    )
    
    # Upload iOS to TestFlight
    upload_to_testflight(
      app_identifier: APP_IDENTIFIER,
      ipa: builds[:ios_ipa],
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      changelog: "Beta release #{version_info[:version]}"
    )
    
    UI.success("‚úÖ Beta release completed:")
    UI.success("  üì± iOS uploaded to TestFlight")
    UI.success("  üñ•Ô∏è macOS: #{builds[:macos_app]}")
    
    builds
  end

  desc "Production release to App Store (v*.*.*)"
  lane :release do
    UI.header("üöÄ Production Release to App Store")
    
    version_info = parse_and_set_version
    UI.message("üì¶ Building release #{version_info[:version]} (#{version_info[:build]})")
    
    # Sync certificates and profiles for App Store distribution
    sync_code_signing(
      type: MATCH_TYPE_APPSTORE,
      additional_platforms: ["catalyst"]
    )
    
    # Build both platforms
    builds = build_multiplatform(
      configuration: "Release", 
      export_method: "app-store",
      output_directory: "./build/release",
      version: version_info[:version],
      match_type: MATCH_TYPE_APPSTORE
    )
    
    # Upload iOS to App Store
    upload_to_app_store(
      app_identifier: APP_IDENTIFIER,
      ipa: builds[:ios_ipa],
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false,
      force: true
    )
    
    UI.success("‚úÖ Production release completed:")
    UI.success("  üì± iOS uploaded to App Store")
    UI.success("  üñ•Ô∏è macOS: #{builds[:macos_app]}")
    
    builds
  end

  # MARK: - Private Helper Lanes

  private_lane :configure_app_store_connect_if_needed do
  next unless ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"]
    
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_CONTENT"],
      is_key_content_base64: true,
      in_house: false
    )
  end

  private_lane :parse_and_set_version do
    # Get tag from environment or git
    tag = ENV['GITHUB_REF_NAME'] || sh("git describe --tags --exact-match HEAD 2>/dev/null || echo ''").strip
    
    UI.message("üè∑Ô∏è Tag: #{tag}")
    
    # Parse version from tag
    if tag.start_with?('v') || tag.start_with?('V')
      # Remove v prefix and parse
      version_string = tag[1..-1]
      
      # Extract base version (without pre-release)
      base_version = version_string.split('-').first
      
      # Set version number
      increment_version_number(
        version_number: base_version,
        xcodeproj: WORKSPACE_PATH
      )
      
      # Determine build number strategy
      build_number = if version_string.include?('-')
        # Pre-release: use timestamp for uniqueness
        Time.now.strftime("%Y%m%d%H%M")
      else
        # Production: use incremental build number
        (latest_testflight_build_number(
          app_identifier: APP_IDENTIFIER,
          version: base_version,
          initial_build_number: 0
        ) || 0) + 1
      end
      
      increment_build_number(
        build_number: build_number,
        xcodeproj: WORKSPACE_PATH
      )
      
      { version: base_version, build: build_number, tag: tag }
    else
      # No tag or invalid format - use current version
      current_version = get_version_number(xcodeproj: WORKSPACE_PATH)
      current_build = get_build_number(xcodeproj: WORKSPACE_PATH)
      { version: current_version, build: current_build, tag: nil }
    end
  end

  private_lane :test_all_platforms do
    UI.header("üß™ Running tests")
    
    # Use Mac Catalyst for fastest test execution
    UI.message("Testing with Mac Catalyst (fastest)")
    
    run_tests(
      scheme: SCHEME_NAME,
      project: WORKSPACE_PATH,
      destination: "platform=macOS,variant=Mac Catalyst",
      code_coverage: true,
      output_types: "junit",
      output_directory: "./fastlane/test_output",
      reset_simulator: false,
      prelaunch_simulator: false
    )
    
    UI.success("‚úÖ Tests passed!")
  end

  private_lane :validate_builds do
    UI.header("üèóÔ∏è Validating builds")
    
    # Quick validation builds without full archiving or signing
    UI.message("Validating iOS build...")
    build_app(
      scheme: SCHEME_NAME,
      project: WORKSPACE_PATH,
      configuration: "Debug",
      destination: "generic/platform=iOS",
      skip_archive: true,
      skip_codesigning: true,
      analyze_build_time: true
    )
    
    UI.message("Validating Mac Catalyst build...")
    build_app(
      scheme: SCHEME_NAME,
      project: WORKSPACE_PATH,
      configuration: "Debug",
      destination: "platform=macOS,variant=Mac Catalyst",
      catalyst_platform: "macos",
      skip_archive: true,
      skip_codesigning: true,
      analyze_build_time: true
    )
    
    UI.success("‚úÖ Build validation passed!")
  end

  private_lane :sync_code_signing do |options|
    UI.message("üîê Syncing #{options[:type]} certificates and profiles")
    
    # Sync iOS certificates and profiles
    match(
      type: options[:type],
      app_identifier: APP_IDENTIFIER,
      platform: "ios",
      readonly: is_ci,
      force_for_new_devices: !is_ci && options[:type] == MATCH_TYPE_DEVELOPMENT
    )
    
    # Sync Mac Catalyst certificates and profiles if needed
    if options[:additional_platforms]&.include?("catalyst")
      UI.message("üñ•Ô∏è Syncing Mac Catalyst certificates and profiles")
      match(
        type: options[:type],
        app_identifier: APP_IDENTIFIER,
        platform: "catalyst",
        readonly: is_ci,
        force_for_new_devices: !is_ci && options[:type] == MATCH_TYPE_DEVELOPMENT
      )
    end
  end

  private_lane :build_multiplatform do |options|
    UI.header("üì¶ Building for multiple platforms")
    
    results = {}
    
    # Build iOS/iPadOS
    UI.message("üì± Building iOS...")
    results[:ios_ipa] = build_ios_platform(options)
    
    # Build Mac Catalyst
    UI.message("üñ•Ô∏è Building Mac Catalyst...")
    results[:macos_app] = build_mac_catalyst_platform(options)
    
    results
  end

  private_lane :build_ios_platform do |options|
    output_name = "AllesTeurer-iOS-#{options[:version]}"
    
    # Get the provisioning profile name from match
    profile_name = get_match_provisioning_profile_name(
      app_identifier: APP_IDENTIFIER,
      type: options[:match_type],
      platform: "ios"
    )
    
    build_app(
      scheme: SCHEME_NAME,
      project: WORKSPACE_PATH,
      configuration: options[:configuration],
      export_method: options[:export_method],
      output_directory: options[:output_directory],
      output_name: output_name,
      destination: "generic/platform=iOS",
      export_team_id: ENV["TEAM_ID"],
      codesigning_identity: get_codesigning_identity(options[:match_type]),
      export_options: {
        method: options[:export_method],
        teamID: ENV["TEAM_ID"],
        signingStyle: "manual",
        provisioningProfiles: {
          APP_IDENTIFIER => profile_name
        }
      }
    )
    
    File.join(options[:output_directory], "#{output_name}.ipa")
  end

  private_lane :build_mac_catalyst_platform do |options|
    output_name = "AllesTeurer-macOS-#{options[:version]}"
    
    # Get the provisioning profile name from match
    profile_name = get_match_provisioning_profile_name(
      app_identifier: APP_IDENTIFIER,
      type: options[:match_type],
      platform: "catalyst"
    )
    
    build_app(
      scheme: SCHEME_NAME,
      project: WORKSPACE_PATH,
      configuration: options[:configuration],
      export_method: options[:export_method],
      output_directory: options[:output_directory],
      output_name: output_name,
      destination: "platform=macOS,variant=Mac Catalyst",
      catalyst_platform: "macos",
      export_team_id: ENV["TEAM_ID"],
      codesigning_identity: get_codesigning_identity(options[:match_type], true),
      export_options: {
        method: options[:export_method],
        teamID: ENV["TEAM_ID"],
        signingStyle: "manual",
        provisioningProfiles: {
          APP_IDENTIFIER => profile_name
        }
      }
    )
    
    # Return the app path
    Dir.glob(File.join(options[:output_directory], "#{output_name}*")).first
  end

  private_lane :get_match_provisioning_profile_name do |options|
    # Match generates profile names in this format
    platform_suffix = options[:platform] == "catalyst" ? " catalyst" : ""
    type_string = case options[:type]
                  when MATCH_TYPE_DEVELOPMENT
                    "Development"
                  when MATCH_TYPE_ADHOC
                    "AdHoc"
                  when MATCH_TYPE_APPSTORE
                    "AppStore"
                  else
                    options[:type].capitalize
                  end
    
    "match #{type_string} #{options[:app_identifier]}#{platform_suffix}"
  end

  private_lane :get_codesigning_identity do |match_type, is_catalyst = false|
    case match_type
    when MATCH_TYPE_APPSTORE
      is_catalyst ? "Apple Distribution" : "iPhone Distribution"
    when MATCH_TYPE_ADHOC
      "iPhone Distribution"
    else # development
      is_catalyst ? "Apple Development" : "iPhone Developer"
    end
  end

  # MARK: - Utility Lanes

  desc "Show current version"
  lane :version do
    version = get_version_number(xcodeproj: WORKSPACE_PATH)
    build = get_build_number(xcodeproj: WORKSPACE_PATH)
    UI.message("üì± Version: #{version} (#{build})")
  end

  desc "Setup certificates for development"
  lane :setup_match do
    UI.header("üîê Setting up Match certificates")
    
    # Development certificates
    match(
      type: MATCH_TYPE_DEVELOPMENT,
      app_identifier: APP_IDENTIFIER,
      platform: "ios",
      readonly: false,
      force: true
    )
    
    match(
      type: MATCH_TYPE_DEVELOPMENT,
      app_identifier: APP_IDENTIFIER,
      platform: "catalyst",
      readonly: false,
      force: true
    )
    
    # App Store certificates
    match(
      type: MATCH_TYPE_APPSTORE,
      app_identifier: APP_IDENTIFIER,
      platform: "ios",
      readonly: false,
      force: true
    )
    
    match(
      type: MATCH_TYPE_APPSTORE,
      app_identifier: APP_IDENTIFIER,
      platform: "catalyst",
      readonly: false,
      force: true
    )
    
    UI.success("‚úÖ Match setup completed!")
  end

  desc "Update certificates and profiles"
  lane :update_certificates do
    sync_code_signing(
      type: MATCH_TYPE_DEVELOPMENT,
      additional_platforms: ["catalyst"]
    )
    
    sync_code_signing(
      type: MATCH_TYPE_APPSTORE,
      additional_platforms: ["catalyst"]
    )
    
    UI.success("‚úÖ Certificates updated!")
  end
  
  desc "Nuke all certificates and start fresh (DANGEROUS)"
  lane :nuke_certificates do
    UI.important("‚ö†Ô∏è This will revoke all certificates and regenerate them!")
    UI.important("‚ö†Ô∏è All team members will need to re-download certificates!")
    
    if UI.confirm("Are you absolutely sure you want to nuke all certificates?")
      match_nuke(
        type: MATCH_TYPE_DEVELOPMENT,
        platform: "ios",
        team_id: ENV["TEAM_ID"]
      )
      
      match_nuke(
        type: MATCH_TYPE_APPSTORE,
        platform: "ios",
        team_id: ENV["TEAM_ID"]
      )
      
      UI.success("‚úÖ Certificates nuked. Run 'fastlane setup_match' to regenerate.")
    else
      UI.message("‚ùå Nuke cancelled.")
    end
  end
end